# Audacity

James Crook

Audacity是一个流行的录音机和音频编辑器程序。它功能强大，而且易于使用。Audacity的主要用户来自Windows平台，不过可以通过编译源码在Linux和Mac平台上运行。

Dominic Mazzoni在1999年写了Audacity的第一版，那时他还只是卡内基梅隆大学的一名研究生（research student）。Dominic目的是创建一个平台，可以在上面开发和调试音频处理算法。不过，这个软件本身逐渐发展，在很多其他方面也变得有用起来。Audacity刚刚宣布作为开源软件发布，它就吸引了别的开发者。多年以来，一个小的、不断变化的、由爱好者组成的团队负责修改、维护、测试、更新、写文档、帮助用户、把Audacity的界面翻译成其他语言。

Audacity的目标之一是它的用户界面应该是可发现的（discoverable）：用户应该不用翻手册，坐下之后就开始使用它，逐渐地发现它的特性。这个原则很关键，为 Audacity赋予更高的用户界面一致性胜过其他。对于有很多人一起合作的项目来说，这种统一的原则比刚开始想象的要更重要。

如果Audacity的架构也有相似的指导原则或者说相似的可发现性就好了。在这方面，我们最接近的原则是“尽量保持一致性”。在增加新代码时，开发者试着遵守附近原有代码的风格和惯例。但是在实践中，Audacity代码库是由组织良好的代码和组织较差的代码混合组成的。相比整体架构，小城市的比喻可能更恰当：小城市里有一些漂亮的建筑，也有一些破旧的地区更像是贫民窟。

## 2.1. Audacity中的结构

Audacity在几个库之上是分层架构的。虽然在Audicity中写新的程序并不需要了解到底这些库具体是怎么回事，但是熟悉它们的API、了解它们的机制也是很重要的。其中最重要的两个库分别是PortAudio，使用提供了跨平台的低级别音频接口和wxWidgets，提供了跨平台的图形用户界面（GUI）组件。

在阅读Audacity源码时，看起来只有代码的一部分是核心。库贡献了很多可选的特性——虽然使用这些特性的人科恩可能没有想到这一点。例如，Audacity有内建的音效功能，同时它也支持LADSPA（Linux音频开发者简单插件API）开发动态载入音效插件。Audicity中的VAMP API对于开发分析音频的插件也起到了相同的作用。没有这些API，Audicity就不会有那么多特性了，但是它本身并不依赖这些特性。

Audicity其他可选的库有libFLAC、ligogg和libvorbis。这些库提供了多种音频压缩格式。通过动态加载LAME或FFmpeg库可以使用MP3格式。授权限制阻止了这些非常流行的压缩库进入Audicity的内建特性。

关于Audicity库和结构的一些决定是由于授权的原因。例如，支持VST插件没有放在里面是因为授权限制。我们也想使用非常高效的FFTW快速傅里叶变换，而不是后退到我们正常构建中使用的有点慢的版本。只要Audacity支持插件，Aducity不用FFTW就有争议。FFTW的作者不想让他们的代码成为其他别的代码的一般性服务。所以，支持插件的架构决定导致我们能提供什么的权衡（重译）。这个决定使得LADSPA插件成为可能，但是阻止我们使用FFTW在我们预构建的二进制里。

架构也会被如何最好地利用我们稀缺的开发者时间这种考虑所影响（重译）。在一个小的开发者团队，我们没有资源去做，例如像Firefox或Thunderbird团队那样，深入分析安全漏洞。然而，我们不想让Audacity提供一个路由穿过防火墙，所以我们有一条规则，那就是彻底切断Audcity的TCP/IP连接。不用TCP/IP就避免了很多安全隐患。了解我们有限的资源，我们就会产生更好的设计。基于这一点，我们去掉一些花费太多开发者时间的特性，而只关心最重要的东西。

对于脚本语言来说，我们也开发者的时间（重译）。我们需要脚本，但是实现脚本语言的代码没有必要包含在Audacity里。把很多份脚本语言编译到Audacity里，让用作出选择并不合适。相反，我们使用一个单独的插件模块和管道实现了脚本，具体内容我们在下面就讲到。

<div align="center"><img src="img/audacity/Layers.png"></div>
<div align="center">图1.1 Audacity中的层次</div>


图2.1展示了Audacity中的一些层和模块。图中强调了wxWidgets中三个重要的类，每个类在Audacity中都有相应实现。我们在从相对较低层次构建更高层次的抽象。例如，BlockFile系统是wxWidgets的wxFiles的映射，并且构建在其上（重译）。在某一阶段，可能把BlockFiles、ShuttleGUI分开比较好，并且把处理逻辑放到中间库中。这会鼓励我们使得它们更加通用。

在图的下侧，有一个窄长条，标题是“平台相关的实现层”（"Platform Specific Implementation Layers"）。wxWidgets和PortAudio都是操作系统（OS）的抽象层。两者都包含条件判断代码，根据目标平台选择不同的实现。

“其他支撑库”（"Other Supporting Libraries"）部分则包含了为数众多的库。有趣的是，其中的很多都依赖于动态加载的模块，而那些动态模块对于wxWidgets一无所知。

在Windows平台上，我们习惯把Audacity编译成一个单独的可执行文件，其中包括了wxWidgets和Audacity的应用程序代码。2008年，我们改成使用一个模块化的结构，把wxWidgets编译成单独的DLL<sup>1</sup>。这样其他可选的DLL就可以在运行时被加载，并且可以使用wxWidgets的特性。图中虚线上方插入的插件可以使用wxWidgets。

把wxWidgets编译成DLL的机制也有弊端。现在的分发包更大了，部分原因是DLL中提供的很多不用的功能之前都会被优化掉。Audacity也需要花更长的时间启动，因为每个DLL都需要分别加载。好处也是显而易见的。我们希望模块化能给我们带来好处，就像Apache一样。就我们的理解，模块化允许Apache的内核非常稳定，同时又能促进模块中的实验、特别的特性和新的想法加入。模块化对于抵挡住拉出一个分支从而把Audacity带到另一个方向的诱惑大有帮助（重译）。我们想这对我们来说是非常重要的变化预案。我们期望得到这些好处，但是还没有看到。把wxWidgets功能暴露出来只是第一步，实际上我们为了得到一个灵活的模块化系统还有更多工作要做。

像Audacity这样的程序结构显然不是事先设计的。它差不多是随着时间逐渐发展起来的。总体来说，我们现在的架构运转的还不错。当我们尝试加入的新特性影响很多源文件时，我们就得和架构作斗争。例如，Audacity现在使用特殊的方式处理立体声和单声道。如果你想要修改Audacity，使它能够处理环绕立体声的话，你就需要在Audacity里改动很多类文件。

>在立体声之外: `GetLink`的故事

>Audacity从来没有过对一些通道的抽象。事实上，它使用的抽象是连接音频通道。有一个函数`GetLink`，如果有两个通道，就会成对返回其他音频通道，而如果音轨是单声道的话，就返回NULL。使用`GetLink`的代码通常看起来好像真的是最初就是为了单声道写的，之后的一个测试`(GetLink() != NULL)`用来扩展原有代码来处理立体声。我不太确定是不是那么写的，但是比较怀疑。使用GetLink的循环没有挨个儿访问链接表（linked list）的所有通道。绘制、混合、读取和写入一个或两个。查看更多通用代码你需要改变大概100个这样对GetLink函数的调用，修改至少26个文件。

>搜索代码找到GetLink的调用很容易，需要作出的修改也并不复杂，所以刚开始听起来修复这个“问题”并不是什么大事。GetLink的故事不是说有一个结构性的缺陷难以修复。相反，它只是想说明一个相对小的缺陷会涉及很多代码，如果任其发展的话。

>以事后来看，把GetLink函数做成私有的（private），而不是提供一个迭代器（iterator）循环访问一个音轨里的每个通道要更好一些。这样就避免了立体声的很多特殊代码，同时使得 使用音频通道立标的代码 全然不知列表的实现。

##2.2. wxWidgets用户界面库（GUI Library）

对Audacity用户界面程序员来说，最重要的一个库就是wxWidgets GUI库，它提供了例如按钮、滑动条、检查按钮、窗口和对话框等等。它提供了大部分可视化的最跨平台行为。wxWidgets库有自己的字符串类wxString，它有对线程、文件系统和字体的跨平台抽象，并且对于其他语言的本地化也有响应的机制，我们都在用。我们建议感刚了解Audacity开发的人首先下载wxWidgets，编译并实验库里面带的一些例子。wxWidgets是在下面操作系统提供的GUI对象之上一个相对薄的层。（什么意思？重译）

为了构建复杂的对话框，wxWidgets不仅提供了单个儿的小部件（widget）元素，而且也提供了大小测定器（sizer）和位置（positions）。这个比只给出图形元素绝对的固定位置要好多了。如果小部件或者被用户直接改变大小，或者例如，因为使用了不同的字体大小而改变了大小，那么对话框里的元素位置自然会随着更新。Sizers（不好译）对于跨平台应用来说是很重要的。没有它们，我们可能不得不为每个平台作出定制化的对话框布局。

通常来说这些对话框的设计存在一个资源文件里，程序会从这个文件读出来。然而，在Audacity里，我们仅仅把对话框设计编译到程序里，作为wxWidgets函数的一系列调用。这提供了最大的灵活性，也就是说，对话框的准确内容和行为会通过应用程序级别的代码来决定。

你可能会发现在Audacity里，创建一个GUI的初始代码是使用一个图形化对话框构建工具产生的。哪些工具帮助我们获得一个基本的设计。随着时间的推移，基本的代码会被hack，加入新特性，结果是很多地方，通过拷贝和编辑现有对话框创建了新的对话框。

然后经过几年这样的开发之后，我们发现Audacit源码里大部分都是配置用户参数，包括相互缠绕的重复代码组成的对话框。那样的代码，虽然做的事情简单，但是已经令人惊讶的难以理解里。问题的一部分是因为对话框的构建太随意了：更小的界面元素合成更大元素最终组成对话框，但是代码创建元素的顺序和屏幕上排列的顺序并不一样。代码也比较冗长，而且重复。有GUI相关的代码，把数据从存在磁盘上的参数转换到临时变量的代码，有把临时变量转换到要显示的GUI的代码，有把显示GUI转换成临时变量存到参数里面的。代码里也有注释，和//this is a mess在一起，但是这些东西已经很久没有人动过了。


## 2.3. ShuttleGui层

解开所有这些代码的方法是使用一个新类，ShuttleGui，它会大幅度减少生成对话框的代码行数，而且使得代码更加易读。ShuttleGui是在wxWidgets库和Audacity之间的一层。它的工作就是在这两层之间转换信息。下面有一个例子代码，就能得到图2.2中所示的GUI元素。

```
ShuttleGui S;
// GUI Structure
S.StartStatic("Some Title",…);
{
    S.AddButton("Some Button",…);
    S.TieCheckbox("Some Checkbox",…);
}
S.EndStatic();
```

<div align="center"><img src="img/audacity/SomeDialog.png"></div>
<div align="center">图2.2 Dialog的例子</div>

上面这段代码在一个对话框中定义了一个静态框，静态框里面包含一个按钮和一个检查框。代码和对话框之间的通信应该是清楚的。StartStatic和EndStatic是成对出现的调用。其他相似的还有StartSomething/EndSomething，都必须要同时出现，用来控制对话框布局的其他方面。大括号和缩进部分不是必需的。我们采用这种惯例，加上之后，可以使得这个结构特别是成对出现的调用更加明显。在更大的例子里对于可读性是很有帮助的。

展示的这段代码没有创建对话框。注释“//GUI Structure”后面的代码也可以用来把对话框的数据传送到用户参数的存储媒介，或者反方向。之前有大量重复的代码需要做这些。现在那种代码只需要写一次，然后隐藏在ShuttleGui类里面就可以了。

Audacity里的基本wxWidgets也有其他的扩展。Audacity有自己管理工具栏的类。它为什么不用wxWidgets内置的工具栏类呢？这里有历史原因：Audacity的工具栏在wxWidgets提供工具栏类之前就写好了。

2.4. TrackPanel（跟踪面板）

Audacity里显示音频波形的主面板是TrackPanel。这是Audacity绘制的定制化组件。它是由组件构成的，例如更小的带有音轨信息的面板，时间座标的标尺，振幅的多个标尺，显示波形的音轨，光谱或字符标签。音轨可以被放大缩小，也可以被拖放移动。包含文本标签的音轨使用自己实现的可编辑文本框，而不是使用内置的文本框。你可以想这些面板音轨和标尺都应该有wxWidgets组件，但不是这样。

<div align="center"><img src="img/audacity/MainPanelAnnotated.png"></div>
<div align="center">图2.3 带有音轨面板元素标签的Audacity界面 </div>


所有这些组件拼在一起使得TrackPanel变得很恐怖。（代码看起来恐怖；用户看到的最终结果还算正常。）GUI和应用相关的代码都混在   一起，没有清晰地分开。在好的设计中，只有我们应用相关的代码知道左侧和右侧的音频通道，分贝，静音和独奏。GUI元素对于应用来说应该是不知道的，它们可以在非音频相关的应用里重用。即使是TrackPanel纯粹的GUI部件也是特殊情景代码的补丁，里面写的都是绝对位置和大小，也不够抽象。如果这些特殊的组件是自我完备的GUI元素，并且如果它们用了和wxWidgets用过的同样的sizer接口，那么就会更好看、清晰和一致。

为了得到这样的一个TrackPanel，我们需要给wxWidgets做一个新的sizer，能够移动和放大缩小音轨，或者，实际上任何其他的小部件。wxWidgets的sizer并不是那么灵活。作为一个附加好处，我们可以在任何地方使用sizer。我们可以把它用在工具栏上，上面放有按钮，使得在工具栏上通过拖动定制按钮的顺序更容易。

在创建和使用这样的sizer的时候做了一些探索性的工作，但是还不够。在把GUI组件做成全功能的wxWidget的有些实验里遇到了问题：这么做减少了我们对于widgets重绘的控制能力，结果导致在调整大小或移动组件的时候发生抖动。我们需要大规模地修改wxWidgets，为了达到无抖动重回的目的，并且把调整大小和重绘的步骤分开。

对于TrackPanel，谨慎使用这个方法的另一个原因是，我们已经知道当有大量widget的时候，wxWidgets就会运行很慢。这个大部分情况下是wxWidget控制不了的。每个wxWidget，按钮和文本框都使用了窗口系统的资源。每个都有一个访问它的句柄。处理大量的资源需要花费时间。即使当widget的大部分是在屏幕上看不见的，处理也比较慢。我们想要能使用很多小的widgets在我们的音轨上。

最好的解决方案是使用一个享元模式，我们自己绘制的轻量级的widgets，没有响应的对象消耗窗口系统的资源或句柄。我们会用一个像wxWidget的sizer的结构和组件widgets，并且给组件提供一个相似的API，但是并不从wxWidgets继承。我们会重构已有的TrackPanel代码，然后它的结构会变得清晰很多。如果这个方案这么容易，我们早就做了，但是有分歧关于我们到底想要什么，最后阻止了更早的尝试。一般化我们现在的临时方案会花费巨大的设计工作和编码。不要再管已经工作的足够好的代码，是一个巨大诱惑。

### 译者注
  1. DLL: DLL Dynamic Link Library 动态链接库
  2. 



